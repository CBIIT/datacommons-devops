@Library('datacommons-jenkins-shared-library@v1.1') _

pipeline {
	agent {
		node {
			label 'cicd_microservice'
		}
	}

 	// parameters {

    //     gitParameter(branchFilter: 'origin/(.*)',
    //         defaultValue: 'main',
    //         name: 'Branch',
    //         type: 'GitParameterDefinition',
    //         quickFilterEnabled: true,
    //         selectedValue: 'DEFAULT',
    //         sortMode: 'ASCENDING_SMART',
    //         tagFilter: '*',
    //         useRepository: 'https://github.com/CBIIT/datacommons-devops.git')
    
		// [[$class: 'CascadeChoiceParameter',
		// 	choiceType: 'PT_MULTI_SELECT',
		// 	filterLength: 1,
		// 	filterable: true,
		// 	name: 'Dockerfiles',
		// 	randomName: 'choice-parameter-35096721380675484',
		// 	referencedParameters: 'Branch',
		// 	script: [$class: 'GroovyScript', fallbackScript: [classpath: [], oldScript: '', sandbox: true, script: 'return ["ERROR"]'], script: [classpath: [], oldScript: '', sandbox: true, script: '''def fileList = [\'/bin/bash\', \'-c\', "git clone --single-branch --branch " + Branch + " https://github.com/CBIIT/datacommons-devops.git > /dev/null 2>&1 ; cd repo ; git ls-tree -r origin/" + Branch + " --name-only"].execute()
			
		// 	fileList.waitFor()
			
		// 	return fileList.text.readLines()''']]]]
		
		// activeChoiceReactiveParam('Dockerfiles') {
	    //     description('Select a Dockerfile')
    	//     filterable()
        // 	choiceType('SINGLE_SELECT')
        // 	groovyScript {
        //     	script("""
	    //             |def fileList = ['/bin/bash', '-c', "git clone --single-branch --branch " + Branch + " https://github.com/CBIIT/datacommons-devops.git > /dev/null 2>&1 ; cd repo ; git ls-tree -r origin/" + Branch + " --name-only"].execute()
    	//             |fileList.waitFor()
        // 	        |return fileList.text.readLines() }
        //     	    """.stripMargin())
        //     	fallbackScript('return ["ERROR"]')
        // 	}
        // 	referencedParameter('Branch')}

//         extendedChoice(
//             name: 'Environment',
//             defaultValue: 'dev',
//             description: 'Choose the environment to build',
//             type: 'PT_SINGLE_SELECT',
//             value: 'dev,qa,stage,prod')

//         gitParameter(branchFilter: 'origin/(.*)',
//             defaultValue: 'main',
//             name: 'CodeBranch',
//             type: 'GitParameterDefinition',
//             quickFilterEnabled: true,
//             selectedValue: 'DEFAULT',
//             sortMode: 'ASCENDING_SMART',
//             tagFilter: '*',
//             useRepository: '')  // Set to the repo URL that you are building

//         booleanParam(
//             defaultValue: true,
//             name: 'UpdateDeploymentVersion')

//         booleanParam(
//             defaultValue: true,
//             name: 'RunDeployStage')

//    }

  options {
	timestamps()
  }

  environment {

    //   PROJECT      = ""   // set to your project name
	//   SERVICE      = ""   // set to your service name
	//   ECR_REPO     = ""   // set to your ECR repo name
	//   DEPLOY_JOB   = ""   // set to your deploy job name
	//   SLACK_SECRET = ""   // set to your slack secret name
	CODE_REPO    = "datacommons-devops"
	//   JOB_PATH     = ""   // set to the base path of the build/deploy jobs you are using
	//   REGION       = "us-east-1"
	//   DEPLOY_REPO  = "${env.PROJECT}-deployments"
    //   CODE_BRANCH  = "${params.CodeBranch}"
	CODE_BRANCH  = "base_image_pipeline"
    //   CODE_FOLDER  = "${env.PROJECT}-${env.SERVICE}"
    CODE_FOLDER  = "datacommons-devops"

  }

  stages{
  	stage('checkout'){
  		steps {

		checkout([$class: 'GitSCM',
			branches: [[name: "${env.CODE_BRANCH}"]],
			extensions: [[$class: 'SubmoduleOption', 
			recursiveSubmodules: true],
			[$class: 'RelativeTargetDirectory',
			relativeTargetDir: "${env.CODE_FOLDER}"]],
			userRemoteConfigs:
			[[url: "https://github.com/CBIIT/${env.CODE_REPO}"]]])

        }

  	}

  	// stage('Set Environment Variables'){

 	// 	steps {

 	// 		script {

    //             // set ECR account number
	// 			env.ECR_ACCOUNT = sh(label: 'Get ECR account', returnStdout: true, script: "aws secretsmanager get-secret-value --region $REGION --secret-id bento/$PROJECT/$ENV --query SecretString --output text | jq -r '.ecr_account'").trim()

	// 			// set repo URL
	// 			env.REPO_URL = "${ECR_ACCOUNT}.dkr.ecr.${REGION}.amazonaws.com/${ECR_REPO}"

	// 		}

 	// 	}

  	// }

	stage('List Dockerfiles'){

 		steps {

 			script {

                list = findFiles(glob: 'docker/base_images/*')

				list.each {
                  println it
				  println it.getName()
				  println it.path
                }

			}

			// input message: 'Select Images To Build', 
			//     parameters: [extendedChoice(multiSelectDelimiter: ',', 
			// 	name: 'Images_to_Build', 
			// 	quoteValue: false, 
			// 	saveJSONParameterToFile: false, 
			// 	type: 'PT_MULTI_SELECT', 
			// 	value: 'list', 
			// 	visibleItemCount: 5)]

 		}

  	}
	
	// stage('Build'){

 	// 	steps {

 	// 		script {

	// 		    sh label: 'Docker-Build', script: '''#!/bin/bash

	// 			# build CTDC Docker container
	// 			echo "Building: $ECR_REPO:$CODE_BRANCH.$BUILD_NUMBER"

	// 			cd $WORKSPACE/$CODE_FOLDER && DOCKER_BUILDKIT=1 docker build --no-cache -t $REPO_URL:$CODE_BRANCH.$BUILD_NUMBER .

	// 			'''

	// 		}

 	// 	}

  	// }

  	// stage('Test'){

    //     agent {
    //         docker {
    //             image 'cbiitssrepo/cicd-ansible_4.0'
    //             args '--net=host -u root -v /var/run/docker.sock:/var/run/docker.sock'
    //             reuseNode true
    //         }
    //     }

 	// 	steps {

 	// 		script {

	// 		    sh label: 'Trivy-Test', script: '''#!/bin/bash

	// 			# Test image for vulnerabilities
    //             echo "Testing Image with Trivy: $ECR_REPO:$CODE_BRANCH.$BUILD_NUMBER"

    //             #trivy image --exit-code 1 --severity HIGH,CRITICAL $REPO_URL:$CODE_BRANCH.$BUILD_NUMBER
    //             trivy image --timeout 15m --severity HIGH,CRITICAL $REPO_URL:$CODE_BRANCH.$BUILD_NUMBER

	// 			'''

	// 		}

 	// 	}

  	// }

  	// stage('push to ECR'){

 	// 	steps {

 	// 		script {

	// 		    sh label: 'Docker-Push', script: '''#!/bin/bash

	// 			# push CTDC Docker container to ECR
	// 			echo "Pushing: $ECR_REPO:$CODE_BRANCH.$BUILD_NUMBER"

	// 			# login and push to ECR
	// 			docker login -u AWS -p $(aws ecr get-login-password --region $REGION) $REPO_URL
	// 			docker push $REPO_URL:$CODE_BRANCH.$BUILD_NUMBER

    //             # tag as latest and push to ECR
	// 			docker tag $REPO_URL:$CODE_BRANCH.$BUILD_NUMBER $REPO_URL:latest
    //             docker push $REPO_URL:latest

	// 			'''

	// 		}

 	// 	}

  	// }

  	// stage('Update Deployment Manifest'){

 	// 	steps {
 			
	// 		script {
    //             if (params.UpdateDeploymentVersion) {
    //                 writeDeployment(
    //                     version: "${env.CODE_BRANCH}.${BUILD_NUMBER}",
    //                     image:  "${env.CODE_BRANCH}.${BUILD_NUMBER}",
    //                     service: "${env.APP}",
    //                     deploymentFile: "${env.PROJECT}-deployments/deployments.yaml",
    //                     deploymentRepoUrl: "https://github.com/CBIIT/${env.DEPLOY_REPO}",
    //                     deploymentCheckoutDirectory: "${env.PROJECT}-deployments"
    //                 )
    //             }
    //         }

 	// 	}

  	// }

  	// stage('Update Code Tag'){

 	// 	steps {
 			
	// 		script {

    //             tagRepo ( 
    //                 gitTag: "${env.CODE_BRANCH}",
    //                 gitUrl: "github.com/CBIIT/${env.CODE_REPO}",
    //                 checkoutDirectory: "${env.CODE_FOLDER}"
    //             )

    //         }

 	// 	}

  	// }

  }

  post {

    // success {

	// 	script {
	// 		if (params.RunDeployStage) {
	// 			echo 'Run the deployment for this sevice'
	// 			build job: "$JOB_PATH/$DEPLOY_JOB", parameters: [string(name: 'ImageTag', value: "$CODE_BRANCH.$BUILD_NUMBER"), extendedChoice(name: 'Environment', value: "$ENV")]
	// 		}
	// 	}
    // }

    // always {

    //     notify(
    //         secretPath: "notification/slack",
    //         secretName: "${env.SLACK_SECRET}"
    //     ) 

    // }

    cleanup {

        cleanWs()

    }

  }

}