@Library('datacommons-jenkins-shared-library@v1.2') _
import groovy.json.JsonSlurper

pipeline {
	agent {
		node {
			label 'slave-ncias-d2940-c'
		}
	}

  parameters {

  string(defaultValue: "michael.fleming@nih.gov,zhengwu.lu@nih.gov,cole.devries@nih.gov", 
        description: 'Enter a list of email addresses to notify with results:', 
        name: 'EmailRecipients')

  }
  
  environment {

 	CODE_REPO   = "datacommons-devops"
    CODE_FOLDER = "datacommons-devops"
 	CODE_BRANCH = "main"

	ECR_REPO    = "cbiit-base-docker-images"
	REGION      = "us-east-1"

	API_URI     = "https://api.github.com"
	ORG         = "CBIIT"

  }

  stages{
  	stage('checkout'){
  		steps {

		checkout([$class: 'GitSCM',
			branches: [[name: "${env.CODE_BRANCH}"]],
			extensions: [[$class: 'SubmoduleOption', 
			recursiveSubmodules: true],
			[$class: 'RelativeTargetDirectory',
			relativeTargetDir: "${env.CODE_FOLDER}"]],
			userRemoteConfigs:
			[[url: "https://github.com/CBIIT/${env.CODE_REPO}"]]])

        }

  	}

   stage('Image Scans'){

 		steps {

 			script {
				// set ECR account number
				env.GITHUB_USER = sh(label: 'Get User', returnStdout: true, script: "aws secretsmanager get-secret-value --region 'us-east-1' --secret-id github/pat --query SecretString --output text | jq -r '.user'").trim()
				env.GITHUB_PAT = sh(label: 'Get PAT', returnStdout: true, script: "aws secretsmanager get-secret-value --region 'us-east-1' --secret-id github/pat --query SecretString --output text | jq -r '.token'").trim()
				
				maskPasswords(varPasswordPairs: [[password: "${env.GITHUB_PAT}"]]){
					REPO_NB_PAGES=sh(label: 'Get repo pages', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -I -s $API_URI/orgs/$ORG/repos\\?page\\=1\\&per_page\\=\\100 | sed -nr 's/^Link:.*page=([0-9]+)&per_page=100.*/\\1/p'").trim()
					println "Repo Pages:  ${REPO_NB_PAGES}"

					def dockerFiles = []
					def baseImages = []

					def page = 1
					while(page <= 1) {    //REPO_NB_PAGES) {
						repos = sh(label: 'get repo names', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/orgs/$ORG/repos\\?page=$page\\&per_page\\=\\100  | jq -r -c '.[].name'").trim().split()
						println "Repos:   ${repos}"
						
						repos.each() {
							println "Repo:     $it"
							
							tree = sh(label: 'get tree url', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/repos/$ORG/$it | grep trees_url | grep $ORG | sed 's/^.*\\(https.*trees\\).*\$/\\1/'").trim()
				 			println "Repo tree master url: $tree"

							branch = sh(label: 'get default branch', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/repos/$ORG/$it | grep -m 1 default_branch | sed -z 's/.*: \"//' | sed -e 's/\",//g'").trim()
							println "Repo default branch: $branch"

							//is_Repo=sh(label: 'check repo status', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | grep -i 'not found' || true")
							repo_empty = sh(label: 'check repo status', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | grep -i 'Git Repository is empty' || true")
							println "Repo Empty:  $repo_empty"
							if (! repo_empty) {
							
							  //url_Dockerfile=sh(label: 'get dockerfile url', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains(\"Dockerfile\"))? |.url'").trim()
							  dockerfilePath = sh(label: 'get dockerfile url', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains(\"Dockerfile\"))? |.path'").trim().split()
							  //println "Dockerfile: $url_Dockerfile"
							  rawUrl =  "https://raw.githubusercontent.com/$ORG/$it/$branch"

							  if (dockerfilePath) {
								repo_name = it
								dockerfilePath.each() {
									println "Dockerfile: $it"
									dockerFiles.add(it)
									//file_content = sh(label: 'get dockerfile content', returnStdout: true, script: "curl -s -J $rawUrl/$it")
									base_image = sh(label: 'get dockerfile base image', returnStdout: true, script: "curl -s -J $rawUrl/$it | grep FROM || echo 'NOT_FOUND'").trim()
									//println "Dockerfile:   $file_content"
									if (!(base_image == 'NOT_FOUND')) {
										image_name = base_image.substring(base_image.indexOf(" ") + 1).trim()
										//image_info = ['Name' : base_image, 'Projects' : repo_name]
										image_info = ['Name' : image_name, 'Projects' : repo_name]
										println "Base Image:   $image_name"
										//baseImages.add(base_image)
										if (baseImages.findResult { it.Name } == image_name) {
											println "Base Image $image_name already used by $it.Project"
											it.Project += ", $repo_name"
											println "Duplicate Images in:     $it.Project"
											baseImages.add(image_info)
										} else {
											baseImages.add(image_info)
										}
									}
								}
							  }
							
							}

							// dockerFiles=sh label: 'Get Dockerfiles', returnStdout: true, script: """#!/bin/bash

							// 	# Retrieve all Dockerfiles of a given Github organization 
							// 	tree=\$(curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/repos/$ORG/$it | grep trees_url | grep $ORG | sed 's/^.*\\(https.*trees\\).*\$/\\1/')
							// 	echo "Repo tree master url: $tree"
							// 	#echo "$API_URI/repos/$ORG/$it"

							// 	branch=\$(curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/repos/$ORG/$it | grep -m 1 default_branch | sed -z 's/.*: "//' | sed -e 's/",//g')
							// 	#echo 'Repo default branch: \$branch'

							// 	is_Dockerfile=\$(curl -u $GITHUB_USER:$GITHUB_PAT -s \$tree/\$branch\\?recursive\\=1 | grep -i 'not found')
							// 	#echo "Is Dockerfile:     \$is_Dockerfile"
							// 	if [ \$? != 0 ] ; then  
							// 		#echo "Files Command:     curl -s \$tree/\$branch\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains("Dockerfile"))? |.url')"
							// 		url_Dockerfile=\$(curl -u $GITHUB_USER:$GITHUB_PAT -s \$tree/\$branch\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains("Dockerfile"))? |.url')
							// 		if [[ ! -z \$url_Dockerfile ]]; then
							// 			echo 'Dockerfile found in repository: $it - Branch: \$branch'
							// 			#curl -H "Accept: application/vnd.github-blob.raw" -s \$url_Dockerfile > ${ORG}-dockerfiles/Dockerfile.\${repo}
							// 		#else
							// 			#echo "No Dockerfile in \$repo"
							// 		fi
							// 	#else
							// 		#echo "Nothing in the repo \$repo"
							// 	fi"""

							// println "Dockerfiles:    ${dockerFiles}"

						}
						page++
					}

					//println dockerFiles
					println baseImages
					//test_search = baseImages.find { it.Name } == "cbiit/centos7_base"
					//println "Results:     $test_search"

					baseImages.each { imageList ->
					  println imageList
					  def currentImage = imageList.find{ it.Name == "cbiit/centos7_base" }
					  if( !(currentImage == null) ) {
						println "Image used for project $imageList.Project"
					  }
					}

				}


				// sh label: 'Get Dockerfiles', script: '''#!/bin/bash

				//     # Retrieve all Dockerfiles of a given Github organization 

				//     # set organization
				//     URI="https://api.github.com"
				//     ORG="CBIIT"

				//     # Get list of repositories
				// 	echo "Retrieving repository list ..."
				// 	#echo "Command is:   curl -I -s $URI/orgs/$ORG/repos\\?page\\=1\\&per_page\\=\\100 | sed -nr 's/^Link:.*page=([0-9]+)&per_page=100.*/\\1/p'"
				// 	REPO_NB_PAGES=$(curl -u $GITHUB_USER:$GITHUB_PAT -I -s $URI/orgs/$ORG/repos\\?page\\=1\\&per_page\\=\\100 | sed -nr 's/^Link:.*page=([0-9]+)&per_page=100.*/\\1/p')
				// 	#echo "Nb pages: $REPO_NB_PAGES"

				//     i=1
				//     #mkdir -p $ORG-dockerfiles
				//     while [ $i -le $REPO_NB_PAGES ]; do
				// 		#echo "repos Command is: curl -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r '.[].name'"
				//     	readarray -t repos <<< $(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].name')
	
				//     	#echo "Repos:  $repos"
						
				// 		for repo in $repos; do
				// 			#echo "Repository: $repo"

				// 			#echo "Tree Cmd:     curl -s $URI/repos/$ORG/$repo | jq -r -c '.[].trees_url' | grep trees_url | grep $ORG | sed 's/^.*\\(https.*trees\\).*$/\\1/'"
				// 			tree=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/repos/$ORG/$repo | grep trees_url | grep $ORG | sed 's/^.*\\(https.*trees\\).*$/\\1/')
				// 			#echo "Repo tree master url: $tree"

				// 			branch=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/repos/$ORG/$repo | grep -m 1 default_branch | sed -z 's/.*: "//' | sed -e 's/",//g')
				// 			#echo "Repo default branch: $branch"

				// 			is_Dockerfile=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | grep -i 'not found')
				// 			#echo "Is Dockerfile:     $is_Dockerfile"
				// 			if [ $? != 0 ] ; then  
				// 				#echo "Files Command:     curl -s $tree/$branch\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains("Dockerfile"))? |.url')"
				// 				url_Dockerfile=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains("Dockerfile"))? |.url')
				// 				if [[ ! -z $url_Dockerfile ]]; then
				// 					echo "Dockerfile found in repository: $repo - Branch: $branch"
				// 					#curl -H "Accept: application/vnd.github-blob.raw" -s $url_Dockerfile > ${ORG}-dockerfiles/Dockerfile.${repo}
				// 				#else
				// 					#echo "No Dockerfile in $repo"
				// 				fi
				// 			#else
				// 				#echo "Nothing in the repo $repo"
				// 			fi
				// 			#break
				//     	done
				// 		break
				//     	i=$(($i + 1))
				//     done'''

			}

 		}

  	}


  }

  post {

	// failure {

	// 	script {

	// 		RESULTS_FILE = sh(label: 'Get results file name', returnStdout: true, script: "echo results_\$(date '+%Y%m%d').txt").trim()
	// 		writeFile(file: RESULTS_FILE, text: RESULTS)
			
	// 		// sh label: 'Write Results', script: """#!/bin/bash

	// 		// 	echo "${RESULTS}" > results_\$(date '+%Y%m%d').txt

	// 		// 	"""

	// 	}
		
	// 	emailext(attachmentsPattern: 'results_*.txt',
	// 		mimeType: 'text/html',
	// 		body: "Base Image scan results attached",
	// 		subject: "Base Image Vulnerabilities Found",
	// 		to: "${EmailRecipients}")
    // }

    cleanup {

        cleanWs()

    }

  }

}