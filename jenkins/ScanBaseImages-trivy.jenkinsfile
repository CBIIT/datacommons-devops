@Library('datacommons-jenkins-shared-library@v1.2') _
import groovy.json.JsonSlurper

pipeline {
	agent {
		node {
			label 'slave-ncias-d2940-c'
		}
	}

  parameters {

  string(defaultValue: "michael.fleming@nih.gov,zhengwu.lu@nih.gov,cole.devries@nih.gov", 
        description: 'Enter a list of email addresses to notify with results:', 
        name: 'EmailRecipients')

  }
  
  environment {

 	CODE_REPO   = "datacommons-devops"
    CODE_FOLDER = "datacommons-devops"
 	CODE_BRANCH = "main"

	ECR_REPO    = "cbiit-base-docker-images"
	REGION      = "us-east-1"

  }

  stages{
  	stage('checkout'){
  		steps {

		checkout([$class: 'GitSCM',
			branches: [[name: "${env.CODE_BRANCH}"]],
			extensions: [[$class: 'SubmoduleOption', 
			recursiveSubmodules: true],
			[$class: 'RelativeTargetDirectory',
			relativeTargetDir: "${env.CODE_FOLDER}"]],
			userRemoteConfigs:
			[[url: "https://github.com/CBIIT/${env.CODE_REPO}"]]])

        }

  	}

   stage('Image Scans'){

 		steps {

 			script {

				//def image_list = readFile("${WORKSPACE}/${CODE_FOLDER}/docker/base_image_list").readLines()
				
				// RESULTS = sh(label: 'Get Scan Results', returnStdout: true, script: """#!/bin/bash
				
				// for image in ${image_list.join(' ')}; do
				// 	trivy_out=\$(docker run --rm --name trivy -u root -v /var/run/docker.sock:/var/run/docker.sock bitnami/trivy:latest image --exit-code 1 --timeout 15m --severity HIGH,CRITICAL \$image)

				// 	if [ \$? == 1 ];	then
				// 	  echo "\$trivy_out \n\n"
				//     fi

                // done

				// """).trim()
				
				//RESULTS = sh(label: 'Get Scan Results', returnStdout: true, script: "curl -L 100 https://api.github.com/orgs/cbiit/repos?per_page=1000").trim()

				// println RESULTS
				// RESULTS.each println(it)
				
				//def list = new JsonSlurper().parseText( RESULTS )
				//list.each { println it.name }

				//json = readJSON(RESULTS)
				
				//json.each JsonOutput.prettyPrint(JsonOutput.toJson(it))

				// if(RESULTS) {
                //     catchError(stageResult: 'FAILURE') {
                //         error 'VULNERABILITIES FOUND'
                //     }
				// }

				// set ECR account number
				env.GITHUB_USER = sh(label: 'Get User', returnStdout: true, script: "aws secretsmanager get-secret-value --region 'us-east-1' --secret-id github/pat --query SecretString --output text | jq -r '.user'").trim()
				env.GITHUB_PAT = sh(label: 'Get PAT', returnStdout: true, script: "aws secretsmanager get-secret-value --region 'us-east-1' --secret-id github/pat --query SecretString --output text | jq -r '.token'").trim()
				
				sh label: 'Get Dockerfiles', script: '''#!/bin/bash

				    # Retrieve all Dockerfiles of a given Github organization 

				    # set organization
				    URI="https://api.github.com"
				    ORG="CBIIT"

				    # Get list of repositories
					echo "Retrieving repository list ..."
					echo "Command is:   curl -I -s $URI/orgs/$ORG/repos\\?page\\=1\\&per_page\\=\\100 | sed -nr 's/^Link:.*page=([0-9]+)&per_page=100.*/\\1/p'"
					REPO_NB_PAGES=$(curl -u $GITHUB_USER:$GITHUB_PAT -I -s $URI/orgs/$ORG/repos\\?page\\=1\\&per_page\\=\\100 | sed -nr 's/^Link:.*page=([0-9]+)&per_page=100.*/\\1/p')
					echo "Nb pages: $REPO_NB_PAGES"

				    i=1
				    #mkdir -p $ORG-dockerfiles
				    while [ $i -le $REPO_NB_PAGES ]; do
				    	#status "Command is: curl -u "{UNAME}:{UPASS}" -s ${URI}/orgs/${ORG}/repos\\?page=${i}\\&per_page\\=\\100  | jq -r '.[].name'"
						echo "repos0 Command is: curl -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r '.[].name'"
				    	readarray -t repos0 <<< $(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].name')
						#repos0=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].name')
				    	echo "repos1 Command is: curl -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].trees_url' | sed -e 's;{/sha};;g'"
						#readarray -t repos1 < <(curl -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].trees_url' | sed -e 's;{/sha};;g')
						readarray -t repos1 <<< $(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].trees_url' | sed -e 's;{/sha};;g')
						#repos1=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].trees_url' | sed -e 's;{/sha};;g')
						#repos1=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $URI/orgs/$ORG/repos\\?page=$i\\&per_page\\=\\100  | jq -r -c '.[].trees_url')
	
				    	echo "Repos0:  $repos0"
						echo "Repos1:  $repos1"
						
						repos1_index=0
				    	for repo in $repos0; do
				    		echo "Repos index: $repos1_index"
							#status "Repository: ${repo}"
							echo "Repository: $repo"
				    		#status "Repos tree master url: $repos1[repos1_index]"
							echo "Repos tree master url: ${repos1[$repos1_index]}"
				    		#curl -s $repos3[repos1_index]/master\\?recursive\\=1 | grep -i 'not found'
							echo "Command:   curl -s ${repos1[$repos1_index]}/master\\?recursive\\=1"
							is_Dockerfile=$(curl -u $GITHUB_USER:$GITHUB_PAT -s ${repos1[$repos1_index]}/master\\?recursive\\=1 | grep -i 'not found')
				    		echo "Is Dockerfile:     $is_Dockerfile"
							if [ $? != 0 ] ; then  
				    			echo "Command:     curl -s $repos1[$repos1_index]/master\\?recursive\\=1"
								url_Dockerfile=$(curl -u $GITHUB_USER:$GITHUB_PAT -s $repos1[$repos1_index]/master\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains("Dockerfile"))? |.url')
				    			if [[ ! -z $url_Dockerfile ]]; then
				    				#status "Dockerfile found!"
									echo "Dockerfile found!"
				    				#curl -H "Accept: application/vnd.github-blob.raw" -s $url_Dockerfile > ${ORG}-dockerfiles/Dockerfile.${repo}
				    			else
				    				#status "No Dockerfile in ${repo}"
									echo "No Dockerfile in $repo"
				    			fi
				    		else
				    			echo "Nothing in the repo $repo"
				    		fi
				    		repos1_index=$(($repos1_index + 1))
				    	done
				    	i=$(($i + 1))
				    done'''

			}

 		}

  	}


  }

  post {

	// failure {

	// 	script {

	// 		RESULTS_FILE = sh(label: 'Get results file name', returnStdout: true, script: "echo results_\$(date '+%Y%m%d').txt").trim()
	// 		writeFile(file: RESULTS_FILE, text: RESULTS)
			
	// 		// sh label: 'Write Results', script: """#!/bin/bash

	// 		// 	echo "${RESULTS}" > results_\$(date '+%Y%m%d').txt

	// 		// 	"""

	// 	}
		
	// 	emailext(attachmentsPattern: 'results_*.txt',
	// 		mimeType: 'text/html',
	// 		body: "Base Image scan results attached",
	// 		subject: "Base Image Vulnerabilities Found",
	// 		to: "${EmailRecipients}")
    // }

    cleanup {

        cleanWs()

    }

  }

}