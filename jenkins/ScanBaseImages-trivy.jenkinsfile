@Library('datacommons-jenkins-shared-library@v1.2') _
import groovy.json.JsonSlurper

pipeline {
	agent {
		node {
			label 'slave-ncias-d2940-c'
		}
	}

  parameters {

  string(defaultValue: "michael.fleming@nih.gov,zhengwu.lu@nih.gov,cole.devries@nih.gov", 
        description: 'Enter a list of email addresses to notify with results:', 
        name: 'EmailRecipients')

  }
  
  environment {

 	CODE_REPO   = "datacommons-devops"
    CODE_FOLDER = "datacommons-devops"
 	CODE_BRANCH = "main"

	ECR_REPO    = "cbiit-base-docker-images"
	REGION      = "us-east-1"

	API_URI     = "https://api.github.com"
	ORG         = "CBIIT"

  }

  stages{
  	stage('checkout'){
  		steps {

		checkout([$class: 'GitSCM',
			branches: [[name: "${env.CODE_BRANCH}"]],
			extensions: [[$class: 'SubmoduleOption', 
			recursiveSubmodules: true],
			[$class: 'RelativeTargetDirectory',
			relativeTargetDir: "${env.CODE_FOLDER}"]],
			userRemoteConfigs:
			[[url: "https://github.com/CBIIT/${env.CODE_REPO}"]]])

        }

  	}

   stage('Image List'){

 		steps {

 			script {
				// set ECR account number
				env.GITHUB_USER = sh(label: 'Get User', returnStdout: true, script: "aws secretsmanager get-secret-value --region 'us-east-1' --secret-id github/pat --query SecretString --output text | jq -r '.user'").trim()
				env.GITHUB_PAT = sh(label: 'Get PAT', returnStdout: true, script: "aws secretsmanager get-secret-value --region 'us-east-1' --secret-id github/pat --query SecretString --output text | jq -r '.token'").trim()
				
				// get list of all base images found in CBIIT repos
				maskPasswords(varPasswordPairs: [[password: "${env.GITHUB_PAT}"]]){
					REPO_NB_PAGES=sh(label: 'Get repo pages', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -I -s $API_URI/orgs/$ORG/repos\\?page\\=1\\&per_page\\=\\100 | sed -nr 's/^Link:.*page=([0-9]+)&per_page=100.*/\\1/p'").trim()
					println "Repo Pages:  ${REPO_NB_PAGES}"

					def dockerFiles = []
					def baseImages = []

					def page = 1
					while(page <= 1) {    //REPO_NB_PAGES) {
						repos = sh(label: 'get repo names', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/orgs/$ORG/repos\\?page=$page\\&per_page\\=\\100  | jq -r -c '.[].name'").trim().split()
						println "Repos:   ${repos}"
						
						repos.each() {
							println "Repo:     $it"
							
							tree = sh(label: 'get tree url', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/repos/$ORG/$it | grep trees_url | grep $ORG | sed 's/^.*\\(https.*trees\\).*\$/\\1/'").trim()
							branch = sh(label: 'get default branch', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $API_URI/repos/$ORG/$it | grep -m 1 default_branch | sed -z 's/.*: \"//' | sed -e 's/\",//g'").trim()
							repo_empty = sh(label: 'check repo status', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | grep -i 'Git Repository is empty' || true")

							if (! repo_empty) {
							
							  dockerfilePath = sh(label: 'get dockerfile url', returnStdout: true, script: "curl -u $GITHUB_USER:$GITHUB_PAT -s $tree/$branch\\?recursive\\=1 | jq -r '.tree[] | select(.path | contains(\"Dockerfile\"))? |.path'").trim().split()
							  rawUrl =  "https://raw.githubusercontent.com/$ORG/$it/$branch"

							  if (dockerfilePath) {
								repo_name = it
								dockerfilePath.each() {
									println "Dockerfile: $it"
									base_image = sh(label: 'get dockerfile base image', returnStdout: true, script: "curl -s -J $rawUrl/$it | grep FROM || echo 'NOT_FOUND'").trim()
									if (!(base_image == 'NOT_FOUND')) {
										image_name = base_image.substring(base_image.indexOf(" ") + 1).trim()
										image_info = [Name:image_name, Projects:repo_name]
										println "Base Image:   $image_name"
										baseImages.add(image_info)
									}
								}
							  }
							
							}
						}
						page++
					}

					println baseImages

					// consolidate base image list to remove duplicate entries
					imageList = []
					baseImages.each { image ->
					  def currentImage = imageList.find{ it.Name == image.Name }
					  if( !(currentImage == null) ) {
						currentImage.Projects += ",$image.Projects"
					  } else {
						imageList.add(image)
					  }
					}

					println imageList

				}

			}

 		}

  	}

	stage('Image Scans'){

 		steps {

 			script {

				println imageList

				RESULTS = ""
				imageList.each { image ->
				    //trivy_out=sh(label: 'Get scan results', returnStdout: true, script: "trivy_out=\$(docker run --rm --name trivy -u root -v /var/run/docker.sock:/var/run/docker.sock bitnami/trivy:latest image --exit-code 1 --timeout 15m --severity HIGH,CRITICAL $image.Name) | if [ \$? == 1 ]; then echo '\$trivy_out \n\n' fi").trim()
					trivy_out=sh(label: 'Get scan results', returnStdout: true, script: "docker run --rm --name trivy -u root -v /var/run/docker.sock:/var/run/docker.sock bitnami/trivy:latest image --timeout 15m --severity HIGH,CRITICAL $image.Name").trim()
					if (!(trivy_out.contains("Total: 0"))) {
					    RESULTS += "\n\n\nTrivy Results: $image.Projects\n$trivy_out"
					}

				}
				


				// RESULTS = sh(label: 'Get Scan Results', returnStdout: true, script: """#!/bin/bash
				
				// for image in ${image_list.join(' ')}; do
				// 	trivy_out=\$(docker run --rm --name trivy -u root -v /var/run/docker.sock:/var/run/docker.sock bitnami/trivy:latest image --exit-code 1 --timeout 15m --severity HIGH,CRITICAL \$image)

				// 	if [ \$? == 1 ];	then
				// 	  echo "\$trivy_out \n\n"
				//     fi

                // done

				// """).trim()

				println RESULTS

				// if(RESULTS) {
                //     catchError(stageResult: 'FAILURE') {
                //         error 'VULNERABILITIES FOUND'
                //     }
				// }

			}

 		}

  	}


  }

  post {

	// failure {

	// 	script {

	// 		RESULTS_FILE = sh(label: 'Get results file name', returnStdout: true, script: "echo results_\$(date '+%Y%m%d').txt").trim()
	// 		writeFile(file: RESULTS_FILE, text: RESULTS)
			
	// 		// sh label: 'Write Results', script: """#!/bin/bash

	// 		// 	echo "${RESULTS}" > results_\$(date '+%Y%m%d').txt

	// 		// 	"""

	// 	}
		
	// 	emailext(attachmentsPattern: 'results_*.txt',
	// 		mimeType: 'text/html',
	// 		body: "Base Image scan results attached",
	// 		subject: "Base Image Vulnerabilities Found",
	// 		to: "${EmailRecipients}")
    // }

    cleanup {

        cleanWs()

    }

  }

}